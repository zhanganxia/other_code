1.多线程共享全局变量：
    多个线程同时操作全局变量会出现资源竞争，数据错乱的问题
    解决方法(可以让一个线程先执行完，再执行另一个)：
        1）time方式延时  -->time.sleep()
        2) 线程等待  -->thread.join()
        同步的方式去执行代码，同步就是按照一定的顺序执行代码
    总结：多线程同时操作全局变量会出现资源竞争的情况，采用同步的方式去执行代码


2.互斥锁(同一时间只有一个线程执行)
------------------------------------------------------
    互斥锁又称为同步锁
    创建过程：
        创建全局互斥锁 ：lock = threading.Lock()
        上锁 ：lock.acquire()
            acquire(True)：True表示堵塞 即如果这个锁在上锁之前已经被上锁了，那么这个线程会在这里一直等待到解锁为止
            acquire(false):表示非堵塞，即不管本次调用能够成功上锁，都不会卡在这，而是继续执行下面的代码
        释放锁 ：lock.release()
        不确定先执行哪个线程，需要给每个线程都添加锁
    注意：互斥锁加上以后，多任务变成单任务，性能会受损
    添加锁位置：
        给关键代码上锁-->每个线程均有执行的机会
        添加在非关键代码位置-->一个线程执行完了，另一个线程开始执行，不管谁先执行完，只要结果

3.死锁(双方相互等待的锁)

4.进程
    定义：一个程序运行起来之后，代码+用到的资源 称之为进程，它是操作系统分配资源的基本单元
    
    每启动一个进程都需要额外开辟资源，会有资源分配，进程只负责所要运行资源，真正干活的是进程中的线程


5.多进程完成多任务
    导入multiprocessing模块
    #group:进程组，一般不用，就是使用目前只能使用None
    multiprocessing.process(group、targert)
    获取当前进程:  -->current_process()
    获取进程编号： -->os.getpid()
    获取父进程编号： -->os.getppid()

    杀死进程：--> os.kill() -->根据指定的进程编号，杀死进程
    process以元组的方式传参  -->args=(1,),
    process以字典的方式传参  -->kwargs{"name":"zax","age":"10"}

    设置成为守护主进程，主进程退出，子进程直接销毁，不再执行
    结束子进程的方式
        第一种方式 设置成为守护主进程
        process.daemon = True
        第二种方式 直接让进程销毁或者给终止进程的执行
        process.terminate() 

    总结：
        1）多进程可以完成多任务同时执行
        2）主进程会等待所有的子进程完成任务以后在退出
        3) 进程间不共享全局变量
            子进程的资源是copy自主进程，两个子进程的全局变量是独立的两个，
            只是恰好名字一样而已，在执行子进程的时候，还是会对自己内部的
            全局变量进行修改
        4）进程和进程之间是相互独立的

6.线程和进程的对比
    1）没有进程就没有线程
    2）进程是系统进行资源分配和调度的一个独立单位
    3）线程是CPU调度和分派的基本单位
    4）一个程序至少有一个进程，一个进程至少有一个线程
    5）多进程开发模式比多线程开发模式健壮性要强
        因为多进程开发某个进程挂掉不会影响其他进程
        的运行，但是多线程开发，如果进程挂了，进程里面
        的所有线程会受影响

7.进程间的通信  
    1）可以通过文件完成进程间的通信
    2）采用消息队列(Queue)也可以完成进程间的通信
        multiprocessing.QUeue(5)
            5-->表示消息队列最大个数，如果不知道就是无限大
    
    put() -->向队列添加消息，会等待
        如果队列满了，在使用put放入数据会等待队列有空闲的位置，才能放入
        成功，否则一直等待
    put_nowait() -->表示不等待队列是否满了直接向消息队列放数据，
        如果队列满了，直接奔溃
    总结：消息队列可以放入任何类型的数据

    queue.get() -->获取队列信息
    queue.get_nowait() -->如果消息队列空了，直接去数据就会奔溃
    queue.full() -->判断消息队列是否满了

8.消息队列演练
    1）向消息队列写入数据
    2）从消息队列读取数据
        判断消息队列是否为空
    3）mian（）
        创建消息队列







